name: Update GitHub Activity

on:
  schedule:
    - cron: '*/60 * * * *'  # Runs every 60 minutes
  workflow_dispatch:  # Allow manual runs
  push:
    branches:
      - main
    paths-ignore:
      - 'README.md'

jobs:
  update-activity:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Setup Git
        run: |
          git config --global user.email "noreply@clovetwilight3.co.uk"
          git config --global user.name "Clove Twilight [Bot]"
      
      - name: Fetch latest changes
        run: |
          git pull origin main
      
      - name: Fetch GitHub activity
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Fetching activity for CloveTwilight3..."
          
          # Function to check if response is valid JSON
          check_json() {
            if ! jq empty "$1" 2>/dev/null; then
              echo "‚ùå Invalid JSON in $1:"
              cat "$1"
              return 1
            fi
            return 0
          }
          
          # Fetch page 1 with authentication
          echo "Fetching page 1..."
          HTTP_STATUS=$(curl -s -w "%{http_code}" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -o activities_page1.json \
            "https://api.github.com/users/clovetwilight3/events?per_page=100")
          echo "HTTP Status for page 1: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "‚ùå Failed to fetch page 1. Status: $HTTP_STATUS"
            echo "Response:"
            cat activities_page1.json
            exit 1
          fi
          
          # Check if page 1 is valid JSON
          if ! check_json "activities_page1.json"; then
            exit 1
          fi
          
          # Fetch page 2 with authentication
          echo "Fetching page 2..."
          HTTP_STATUS=$(curl -s -w "%{http_code}" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -o activities_page2.json \
            "https://api.github.com/users/clovetwilight3/events?per_page=100&page=2")
          echo "HTTP Status for page 2: $HTTP_STATUS"
          
          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "‚ùå Failed to fetch page 2. Status: $HTTP_STATUS"
            echo "Response:"
            cat activities_page2.json
            # For page 2, we can continue with just page 1
            echo "Continuing with page 1 only..."
            cp activities_page1.json activities.json
          else
            # Check if page 2 is valid JSON
            if ! check_json "activities_page2.json"; then
              echo "Page 2 invalid, using page 1 only..."
              cp activities_page1.json activities.json
            else
              # Combine the results
              echo "Combining pages..."
              jq -s '.[0] + .[1]' activities_page1.json activities_page2.json > activities.json
            fi
          fi
          
          # Verify final JSON is valid
          if ! check_json "activities.json"; then
            echo "‚ùå Final activities.json is invalid"
            exit 1
          fi
          
          echo "‚úÖ Successfully fetched and validated activity data"
          echo "Total events: $(jq length activities.json)"
      
      - name: Process activity and update README
        run: |
          # Create a script to process the JSON and update README
          cat > process.js << 'EOF'
          const fs = require('fs');
          
          try {
            let activities = JSON.parse(fs.readFileSync('activities.json', 'utf8'));
            
            // Priority repositories
            const priorityRepos = ['RoomMates-Helper', 'plural-web', 'spotify-player', 'EMIS', 'pluralkit-discord-overlay', 'Custom-DiscordRPC'];
            
            // Repositories to ignore
            const ignoreRepos = ['github-activity-tracker', 'clovetwilight3', 'clovetwilight3.github.io'];
            
            console.log(`Total activities fetched: ${activities.length}`);
            
            // Handle case where activities might be empty
            if (!Array.isArray(activities) || activities.length === 0) {
              console.log("No activities found or invalid data format");
              
              // Create fallback content
              const timestamp = new Date().toLocaleString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric', 
                hour: 'numeric', 
                minute: 'numeric'
              });
              
              const updatedSection = `<!--ACTIVITY:START-->\n_No recent activity found_\n\n*Last Updated: ${timestamp}*\n<!--ACTIVITY:END-->`;
              
              const readmePath = './README.md';
              let readme = fs.readFileSync(readmePath, 'utf8');
              
              readme = readme.replace(
                /<!--ACTIVITY:START-->[\s\S]*<!--ACTIVITY:END-->/,
                updatedSection
              );
              
              fs.writeFileSync(readmePath, readme, 'utf8');
              console.log('‚úÖ Updated README with fallback message');
              process.exit(0);
            }
            
            // Filter out ignored repositories
            const filteredActivities = activities.filter(event => {
              if (!event.repo || !event.repo.name) return false;
              const repo = event.repo.name.split('/')[1];
              return !ignoreRepos.includes(repo);
            });
            
            console.log(`Activities after filtering: ${filteredActivities.length}`);
            
            // Sort by date (newest first)
            const sortedActivities = filteredActivities.sort((a, b) => {
              return new Date(b.created_at) - new Date(a.created_at);
            });
            
            // Format activities
            const formattedActivities = sortedActivities.slice(0, 50).map(event => {
              const repo = event.repo.name.split('/')[1];
              const date = new Date(event.created_at).toLocaleString();
              
              try {
                switch (event.type) {
                  case 'PushEvent':
                    const commits = event.payload.commits || [];
                    const commitMessages = commits.length > 0 
                      ? commits.map(c => c.message.split('\n')[0]).slice(0, 2).join(', ') 
                      : '';
                    const shortMessage = commitMessages.length > 0 
                      ? ` (${commitMessages}${commits.length > 2 ? '...' : ''})` 
                      : '';
                    return `üìä Pushed ${commits.length} commit(s) to \`${repo}\`${shortMessage} - ${date}`;
                  case 'IssuesEvent':
                    const issueTitle = event.payload.issue?.title || '';
                    const issueAction = event.payload.action || '';
                    return `${issueAction === 'opened' ? '‚ùóÔ∏è' : '‚úÖ'} ${issueAction} issue #${event.payload.issue.number} in \`${repo}\` (${issueTitle}) - ${date}`;
                  case 'PullRequestEvent':
                    const prTitle = event.payload.pull_request?.title || '';
                    const prAction = event.payload.action || '';
                    return `${prAction === 'opened' ? 'üí™' : 'üîÑ'} ${prAction} PR #${event.payload.pull_request.number} in \`${repo}\` (${prTitle}) - ${date}`;
                  case 'CreateEvent':
                    return `üå± Created ${event.payload.ref_type} \`${event.payload.ref || ''}\` in \`${repo}\` - ${date}`;
                  case 'ReleaseEvent':
                    return `üöÄ Released version ${event.payload.release.tag_name} of \`${repo}\` - ${date}`;
                  case 'WatchEvent':
                    return `‚≠ê Starred \`${repo}\` - ${date}`;
                  case 'ForkEvent':
                    return `üç¥ Forked \`${repo}\` - ${date}`;
                  case 'DeleteEvent':
                    return `üóëÔ∏è Deleted ${event.payload.ref_type} \`${event.payload.ref}\` from \`${repo}\` - ${date}`;
                  case 'PublicEvent':
                    return `üåü Made \`${repo}\` public - ${date}`;
                  case 'CommitCommentEvent':
                    return `üí¨ Commented on commit in \`${repo}\` - ${date}`;
                  case 'IssueCommentEvent':
                    return `üí¨ Commented on issue #${event.payload.issue.number} in \`${repo}\` - ${date}`;
                  case 'MemberEvent':
                    return `üë• ${event.payload.action} user ${event.payload.member.login} to \`${repo}\` - ${date}`;
                  default:
                    return `üîß ${event.type} in \`${repo}\` - ${date}`;
                }
              } catch (error) {
                console.error(`Error processing event: ${error.message}`);
                return `üîß Activity in \`${repo}\` - ${date}`;
              }
            });
            
            // Apply priority sorting
            const prioritySorted = [...formattedActivities].sort((a, b) => {
              const aIsPriority = priorityRepos.some(repo => a.includes(`\`${repo}\``));
              const bIsPriority = priorityRepos.some(repo => b.includes(`\`${repo}\``));
              
              if ((aIsPriority && bIsPriority) || (!aIsPriority && !bIsPriority)) return 0;
              if (aIsPriority && !bIsPriority) return -1;
              if (!aIsPriority && bIsPriority) return 1;
              return 0;
            });
            
            // Take exactly 5 activities
            const topActivities = prioritySorted.slice(0, 5);
            
            // Create the markdown
            const timestamp = new Date().toLocaleString('en-US', { 
              weekday: 'long', 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric', 
              hour: 'numeric', 
              minute: 'numeric'
            });
            
            let activityMarkdown = '';
            
            if (topActivities.length > 0) {
              activityMarkdown = topActivities.map(activity => `1. ${activity}`).join('\n');
            } else {
              activityMarkdown = "_No recent activity found_";
            }
            
            const updatedSection = `<!--ACTIVITY:START-->\n${activityMarkdown}\n\n*Last Updated: ${timestamp}*\n<!--ACTIVITY:END-->`;
            
            // Read README and update it
            const readmePath = './README.md';
            let readme = fs.readFileSync(readmePath, 'utf8');
            
            readme = readme.replace(
              /<!--ACTIVITY:START-->[\s\S]*<!--ACTIVITY:END-->/,
              updatedSection
            );
            
            fs.writeFileSync(readmePath, readme, 'utf8');
            console.log('‚úÖ Successfully updated README with recent activities');
            
          } catch (error) {
            console.error('‚ùå Error processing activities:', error.message);
            process.exit(1);
          }
          EOF
          
          # Run the script
          node process.js
      
      - name: Commit and push changes
        run: |
          git add README.md
          
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "üìä Update GitHub activity"
            git push
